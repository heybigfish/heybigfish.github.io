<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的生活~</title>
  
  
  <link href="https://heybigfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://heybigfish.github.io/"/>
  <updated>2021-07-29T10:54:04.862Z</updated>
  <id>https://heybigfish.github.io/</id>
  
  <author>
    <name>bigfish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript-基础</title>
    <link href="https://heybigfish.github.io/2021/07/19/TypeScript-%E5%9F%BA%E7%A1%80/"/>
    <id>https://heybigfish.github.io/2021/07/19/TypeScript-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-19T03:43:54.000Z</published>
    <updated>2021-07-29T10:54:04.862Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JavaScript 的特性</strong></p><ul><li>它没有类型约束，一个变量可能初始化时是字符串，又被赋值为数字。</li><li>存在大量的隐式转换，变量类型难以确定。</li><li>原型上的属性或方法可以在运行时被修改。</li><li>解释性语言，没有编译阶段，属于动态类型。（运行时报错）</li></ul><p><strong>TypeScript 的特性</strong></p><ul><li>TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。</li><li>静态类型，「类型」是 TypeScript 最核心的特性，运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查。</li><li>弱类型，完全兼容 JavaScript ，不会修改 JavaScript 运行时的特性。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>布尔值时最基础的数据类型。</p><pre><code class="ts">let show: boolean = false;// 编译通过</code></pre><p>需要注意的是，构造函数 <code>Boolean</code> 创造的是一个 <code>Boolean</code> 对象,并不是布尔值。</p><pre><code class="ts">let createBoolean: Boolean = new Boolean(true);//  Boolean &#123;true&#125;</code></pre><p>直接调用会 <code>Boolean</code> 则可以返回 <code>boolean</code> 值。</p><pre><code class="ts">let createBoolean: boolean = Boolean(true);// true</code></pre><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><pre><code class="ts">let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code class="ts">let name: string = &quot;Tree&quot;;</code></pre><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p><code>JavaScript</code> 没有空值(Viid)的概念，在 <code>TypeScript</code> 中，可以使用 <code>void</code> 表示没有任何返回值的函数：</p><pre><code class="ts">function count(): void &#123;  let num: number = 0;  num++;&#125;</code></pre><p>声明没有返回值函数存在意义，声明 <code>void</code> 变量则没有意义，只能将它赋值给 <code>undefined</code> 和 <code>null</code></p><pre><code class="ts">let unusable: void = undefined;let unvalue: void = null;</code></pre><h4 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h4><p>在 <code>TypeScript</code> 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p><pre><code class="ts">let u: undefined = undefined;let n: null = null;</code></pre><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 <strong>任意</strong> 类型的变量：</p><pre><code class="ts">// 这样不会报错let num: number = undefined;</code></pre><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p>普通类型，在赋值过程中改变类型是不被允许的，。<br>如果是 <code>any</code> 类型，则允许被赋值为<strong>任意类型</strong>，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p><p>任意值上访问任何熟悉都是允许的。</p><pre><code class="ts">let number: string = &quot;1&quot;;number = 1;let anyThing: any = &quot;hello&quot;;console.log(anyThing.number);console.log(anyThing.number.age);</code></pre><p>也允许调用任何方法：</p><pre><code class="ts">let anyThing: any = &quot;sleep&quot;;anyThing.time(&quot;1000&quot;);anyThing.time(&quot;1000&quot;).do();</code></pre><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong></p><pre><code class="ts">let something;something = &quot;1&quot;;something = 1;</code></pre><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p><code>TypeScript</code> 会在没有明确的指定类型的时候,根据赋值推测出一个类型。<br>如果定义的时候没有赋值，都会被推断成 any 类型而完全不被类型检查</p><pre><code class="ts">let num;num = &quot;7&quot;;num = 7;</code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型,表示取值可以为多种类型中的一种。</p><pre><code class="ts">let num: number | string;num = &quot;1&quot;;num = 1;</code></pre><p><strong>访问联合类型的属性或方法</strong><br>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p><pre><code class="ts">function getLength(e: string | number) &#123;  return e.length;&#125;// 编译失败。</code></pre><p><code>length</code> 不是<code>number</code>和<code>string</code>的共有属性，所以会报错。</p><pre><code class="ts">function toString(e: string | number) &#123;  return e.toString();&#125;// 编译成功，toString() 是共有属性。</code></pre><p>当联合类型的变量在赋值的时候，会根据类型推断出一个类型。</p><pre><code class="ts">let num: string | number;num = &quot;1&quot;;console.log(num.length); // 编译成功，类型推断为 string，访问length成功。num = 1;console.log(num.length); // 编译报错，类型推断为 number，访问length失败。</code></pre><h3 id="对象的类型-接口-Interfaces"><a href="#对象的类型-接口-Interfaces" class="headerlink" title="对象的类型 - 接口 (Interfaces)"></a>对象的类型 - 接口 (Interfaces)</h3><p>在 <code>TypeScript</code> 中，使用接口来定义对象的类型，结构。</p><pre><code class="ts">interface Person &#123;  name: string;  age: number;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  age: 25,&#125;;</code></pre><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p><p><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong><br>对象定义的变量比接口少或者多一些属性是不允许的。</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,&#125;;let Jenny: Person = &#123;  name: &quot;Jenny&quot;,  age: 21,&#125;;</code></pre><p>使用<code>?</code>修饰的变量，可以不存在，但是 <strong>仍然不允许添加未定义的属性。</strong></p><h4 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h4><p>如果希望接口中允许存在任意属性的变量，可以使用<code>[propName: string]: any]</code> 进行修饰。</p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;  [propName: string]: any;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  gender: &quot;male&quot;,&#125;;</code></pre><p>注意：<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</strong></p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;  [propName: string]: string;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  age: 25,  gender: &quot;male&quot;,&#125;;//  编译失败</code></pre><p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p><p>可以使用联合类型进行处理：</p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;  [propName: string]: string | number;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  age: 25,  gender: &quot;male&quot;,&#125;;</code></pre><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>如果希望对象中的部分属性，只能在被创建的时候被赋值，且不能被修改， 可以使用 <code>readonly</code> 进行修饰属性。</p><pre><code class="ts">interface Person &#123;  readonly id: number;  name: string;  age?: number;  [propName: string]: any;&#125;let tom: Person = &#123;  id: 9527,  name: &quot;Tom&quot;,  age: 21,  gender: &quot;male&quot;,&#125;;tom.id = 123; // 编译报错，id为只读属性。</code></pre><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><p>在 TypeScript 中，数组的类型有多种定义方式。</p><h4 id="「类型-方括号」"><a href="#「类型-方括号」" class="headerlink" title="「类型 + 方括号」"></a>「类型 + 方括号」</h4><p>最简单、直观的一种方式。</p><pre><code class="ts">let arr: number[] = [1, 2, 3, 4, 5];</code></pre><p>上例中，数组中的每一项都必须是 <code>number</code> 类型。</p><h4 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h4><p>使用数组泛型来定义数组类型</p><pre><code class="ts">let nums: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre><h4 id="接口表示数组"><a href="#接口表示数组" class="headerlink" title="接口表示数组"></a>接口表示数组</h4><p>数组是对象，使用接口定义数组类型。</p><pre><code class="ts">interface NumberArray &#123;  [index: number]: number;&#125;let nums: NumberArray = [1, 1, 2, 3, 5];</code></pre><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><p>类数组不是普通的数组，只能使用接口进行描述。<br>以 <code>arguments</code> 为例。</p><pre><code class="ts">function count() &#123;  let args: &#123;    [index: number]: number;    length: number;    callee: Function;  &#125; = arguments;&#125;</code></pre><p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p><pre><code class="ts">function count() &#123;  let args: IArguments = arguments;&#125;</code></pre><p>其中 <code>IArguments</code> 是 TypeScript 中定义好的内容。 等价于下例。</p><pre><code class="ts">interface IArguments &#123;  [index: number]: number;  length: number;  callee: Function;&#125;</code></pre><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束。</p><pre><code class="ts">function count(x: number, y: number): number &#123;  return x + y;&#125;</code></pre><p><strong>输入不符合约束或者输出约束的输出，都是不被允许的。</strong></p><pre><code class="ts">let count = function (x: number, y: number): number &#123;  return x + y;&#125;;</code></pre><p>上例中只是对右侧的函数进行了类型定义，左侧的变量是通过类型推论而推断出了类型定义。</p><p>完整示例：</p><pre><code class="ts">let count: (x: number, y: number) =&gt; number = function (  x: number,  y: number): number &#123;  return x + y;&#125;;</code></pre><ul><li>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的返回值。</li><li>在 ES6 中，<code>=&gt;</code> 叫做箭头函数。</li></ul><p>函数是特殊的对象，所以也可以使用接口定义函数类型。</p><pre><code class="ts">interface Nums &#123;  (x: number, y: number): number;&#125;let nums: Nums = function (x: number, y: number): number &#123;  return x + y;&#125;;</code></pre><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>用 <code>?</code> 表示可选的参数。</p><pre><code class="ts">function count(x: number, y: number, z?: number): number &#123;  if (z) &#123;    return x + y + z;  &#125; else &#123;    return x + y;  &#125;&#125;count(1, 2);</code></pre><p>注意,<strong>可选参数必须在必需参数后面</strong> 也就是说，可选参数后面不允许在出现必选参数。</p><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>ES6 中对函数的参数添加了默认值，在 TypeScript 中，对于添加了默认值的参数，识别为可选参数，且和参数出现顺序无关，不必遵守 【可选参数必须在必需参数后面】。</p><h4 id="剩余参数（rest-参数）"><a href="#剩余参数（rest-参数）" class="headerlink" title="剩余参数（rest 参数）"></a>剩余参数（rest 参数）</h4><p>ES6 中，可以使用 …rest 的方式获取函数中的剩余参数，rest 是一个数组，可以通过数组的类型来定义。</p><pre><code class="ts">function doRest(array: any[], ...items: any[]) &#123;  items.forEach(function (item) &#123;    array.push(item);  &#125;);&#125;let arr = [];doRest(arr, 1, 2, 3);</code></pre><p>注意：<strong>rest 参数只能是最后一个参数</strong></p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载允许一个函数接受不同数量、类型的参数时，做出不同的处理。<br>栗子一：实现 <code>reverse</code> 函数，反转输入的参数。123==&gt; 321; ‘hello’==&gt;’olleh’。</p><pre><code class="ts">function reverse(x: number | string): number | string | void &#123;  if (typeof x === &quot;number&quot;) &#123;    return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;));  &#125; else if (typeof x === &quot;string&quot;) &#123;    return x.split(&quot;&quot;).reverse().join(&quot;&quot;);  &#125;&#125;</code></pre><p>基本实现需求，但是会存在一个问题，函数定义比较模糊，参数为数字时，返回值应该是数字。参数为字符串时，返回值应该是字符串，上例不能很好的处理这个问题。</p><p>借助函数的<strong>重载</strong>可以很好的解决这个问题。</p><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string | void &#123;  if (typeof x === &quot;number&quot;) &#123;    return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;));  &#125; else if (typeof x === &quot;string&quot;) &#123;    return x.split(&quot;&quot;).reverse().join(&quot;&quot;);  &#125;&#125;</code></pre><p>上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p><p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言可以手动的指定一个值的类型。</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p><code>值 as 类型</code> 或者 <code>&lt;类型&gt;值</code> ;</p><p>由于 <code>&lt; &gt;</code> 也有表示泛型的意思，为了避免混淆，建议使用 <code>值 as 类型</code> 的写法进行使用类型断言。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="将一个联合类型断言为其中一个类型"><a href="#将一个联合类型断言为其中一个类型" class="headerlink" title="将一个联合类型断言为其中一个类型"></a>将一个联合类型断言为其中一个类型</h5><p>当 TypeScript 不确定一个联合类型的变量到底是哪一种时，通常只能访问联合类型中的共有属性或方法。</p><pre><code class="ts">interface Cat &#123;  name: string;  run(): void;&#125;interface Fish &#123;  name: string;  swim(): void;&#125;function getName(something: Cat | Fish): string &#123;  return something.name;&#125;</code></pre><p>有时候，不确定类型的时候就要访问一个类型特有的属性或者方法。</p><pre><code class="ts">interface Cat &#123;  name: string;  run(): void;&#125;interface Fish &#123;  name: string;  swim(): void;&#125;function isCat(something: Cat | Fish): boolean &#123;  if (something.run) &#123;    return true;  &#125;  return false;&#125;</code></pre><p>因为类型 Filsh 没有 run 的属性和方法，所以编译失败.<br>此时可以使用类型断言，将 something 断言为 Cat</p><pre><code class="ts">interface Cat &#123;  name: string;  run(): void;&#125;interface Fish &#123;  name: string;  swim(): void;&#125;function isCat(something: Cat | Fish): boolean &#123;  if ((something as Cat).run) &#123;    return true;  &#125;  return false;&#125;</code></pre><p>类型断言是能够避免编译阶段的报错，不能避免运行时的报错。<br>谨慎使用类型断言，避免产生一些不必要的错误。</p><h5 id="将一个父类断言为具体的子类"><a href="#将一个父类断言为具体的子类" class="headerlink" title="将一个父类断言为具体的子类"></a>将一个父类断言为具体的子类</h5><pre><code class="ts">class Animal &#123;&#125;class Cat extends Animal &#123;  run() &#123;    console.log(&quot;running&quot;);  &#125;&#125;class Brid extends Animal &#123;  fly() &#123;    console.log(&quot;flying&quot;);  &#125;&#125;function doSomething(something: Animal): void &#123;  if ((something as Brid).fly) &#123;    console.log(&quot;this is brid&quot;);  &#125;&#125;</code></pre><p><code>class</code> 实现的类，属于 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 实例与类之间的关系。 [<code>something instanceof Brid</code>]</p><p>一般情况下，Cat 和 Brid 只是一个 TypeScript 的接口，并不是真正意义的值，只是对象的描述信息，编译过程中会被删除，所以不能用 instanceof 进行判断。这时候只能使用 [类型断言] 进行判断。</p><pre><code class="ts">interface Animal &#123;&#125;interface Cat extends Animal &#123;  run() &#123;    console.log(&quot;running&quot;);  &#125;&#125;interface Brid extends Animal &#123;  fly() &#123;    console.log(&quot;flying&quot;);  &#125;&#125;function doSomething(something: Animal): void &#123;  if ((something as Brid).fly) &#123;    console.log(&quot;this is brid&quot;);  &#125;&#125;</code></pre><h5 id="将任何一个类型断言为-any"><a href="#将任何一个类型断言为-any" class="headerlink" title="将任何一个类型断言为 any"></a>将任何一个类型断言为 <code>any</code></h5><p>理想状态下，TypeScript 的类型界定具体，明确，调用类型上不存在的属性和方法时，会报错</p><pre><code class="ts">const foo: number = 1;foo.length = 1;// 类型“number”上不存在属性“length”。ts</code></pre><p>这种报错信息简单而有效。</p><p>但是存在某些情况，非常确信代码不会发生错误。</p><pre><code class="ts">window.foo = 1;// 类型“Window &amp; typeof globalThis”上不存在属性“foo”。</code></pre><p>如果对 window 对象 添加属性 <code>foo</code>, 但是 TypeScript 编译会报错。<br>此时可以使用 <code>as any</code> 临时断言 <code>window</code> 对象为 <code>any</code> 类型。</p><pre><code class="ts">(window as any).foo = 1;</code></pre><p>需要注意的时，将一个变量断言为 <code>any</code> 是 TypeScript 中解决类型问题的最后一个手段。</p><h5 id="将-any-断言为一个具体的类型。"><a href="#将-any-断言为一个具体的类型。" class="headerlink" title="将 any 断言为一个具体的类型。"></a>将 <code>any</code> 断言为一个具体的类型。</h5><p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。<br>我们可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型。</p><pre><code class="ts">function anyAnimal(key: string): any &#123;  let obj = &#123;    name: key,  &#125;;  return obj;&#125;interface Cat &#123;  name: string;  run(): void;&#125;const tom = anyAnimal(&quot;tom&quot;) as Cat;tom.run();</code></pre><p>上例中明确了 tom 的类型为 <code>Cat</code>,对于后续的维护工作比较友好。</p><h4 id="类型断言的限制"><a href="#类型断言的限制" class="headerlink" title="类型断言的限制"></a>类型断言的限制</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;JavaScript 的特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它没有类型约束，一个变量可能初始化时是字符串，又被赋值为数字。&lt;/li&gt;
&lt;li&gt;存在大量的隐式转换，变量类型难以确定。&lt;/li&gt;
&lt;li&gt;原型上的属性或方法可以在运行时被修改。&lt;/l</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://heybigfish.github.io/categories/TypeScript/"/>
    
    
    <category term="基础" scheme="https://heybigfish.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
