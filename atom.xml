<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的生活~</title>
  
  
  <link href="https://heybigfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://heybigfish.github.io/"/>
  <updated>2021-08-20T03:12:32.947Z</updated>
  <id>https://heybigfish.github.io/</id>
  
  <author>
    <name>bigfish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue3-组合API(Composition API)</title>
    <link href="https://heybigfish.github.io/2021/08/16/vue3-%E7%BB%84%E5%90%88API/"/>
    <id>https://heybigfish.github.io/2021/08/16/vue3-%E7%BB%84%E5%90%88API/</id>
    <published>2021-08-16T01:39:24.000Z</published>
    <updated>2021-08-20T03:12:32.947Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/tree.png" alt="tree"></p><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p><code>setup</code> 函数是一个新的组件选项，是组件内使用 组合 API（Composition API）的入口.</p><ul><li><p><strong>调用顺序</strong></p><ul><li>创建实组件实例</li><li>初始化 <code>props</code></li><li>调用 <code>setup</code> 函数</li><li>正常的组件生命周期</li></ul></li></ul><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li><p><strong><code>props</code> 作为其第一个参数</strong></p><ul><li><p><code>props</code> 对象是响应式的，<code>watchEffect</code> 或 <code>watch</code> 会观察和响应 <code>props</code> 的更新。</p></li><li><p><strong>不能</strong> 解构 <code>props</code> 对象，因为会使其丢失掉响应性。</p></li><li><p><code>props</code> 的代码空间是不可变的，尝试修改 <code>props</code> 时会触发警告。</p><pre><code>```jsexport default &#123;  props: &#123;    name: String,  &#125;,  setup(props) &#123;    console.log(props.name);    watchEffect(() =&gt; &#123;      console.log(`name is: ` + props.name);    &#125;);  &#125;,&#125;;```</code></pre></li></ul></li><li><p><strong><code>context</code>(上下文对象) 作为第二个参数</strong></p><p>上下文对象从 2.x 中的 <code>this</code> 选择性的暴露出一些 property.</p><pre><code class="js">export default &#123;  setup(props, context) &#123;    return &#123;      attrs: context.attrs,      slots: context.slots,      emit: context.emit,    &#125;;  &#125;,&#125;;</code></pre><p><code>attrs</code> 和 <code>slots</code> 都是内部组件实例上对应项的代理(<code>proxy</code>),可以确保其是响应式数据,即为最新值,可以对其进行解构.</p><pre><code class="js">export default &#123;  setup(props, &#123; attrs, slots &#125;) &#123;    return &#123;      attrs,      slots,    &#125;;  &#125;,&#125;;</code></pre></li></ul><h5 id="this-的用法"><a href="#this-的用法" class="headerlink" title="this 的用法"></a><code>this</code> 的用法</h5><p><strong>this 在 <code>setup()</code> 中不可用。</strong><br>由于<code>setup</code>函数在 <code>beforeCreate</code> 钩子执行前触发,当前实例的 <code>data</code> 和 <code>el</code> 还没有初始化.</p><h5 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h5><p>为了获得传递给 setup() 参数的类型推断，需要使用 <code>defineComponent</code>。</p><pre><code class="ts">interface Data &#123;  [key: string]: unknown;&#125;interface Slots &#123;  [key: string]: unknown;&#125;interface SetupContext &#123;  attrs: Data;  slots: Slots;  emit: (event: string, ...args: unknown[]) =&gt; void;&#125;function setup(props: Data, context: SetupContext): Data;</code></pre><h4 id="响应式系统-API"><a href="#响应式系统-API" class="headerlink" title="响应式系统 API"></a>响应式系统 API</h4><h5 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a><code>reactive</code></h5><p>接收一个普通的对象然后返回该对象的响应式代理.</p><pre><code class="js">const obj = reactive(&#123; count: 0 &#125;);</code></pre><p>响应式转换时深层次的,会影响对象内部虽有嵌套的属性,基于 es6 <code>Proxy</code> 实现,返回代理对象<strong>不等于</strong>原始对象.开发中使用代理对象而避免依赖原始对象.</p><ul><li><p>类型定义</p><pre><code class="ts">function reactive&lt;T extends object&gt;(raw: T): T;</code></pre></li></ul><h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a><code>ref</code></h5><p>接收一个基础类型的值,返回一个可以响应式且可以改变的<code>ref</code>对象.<code>ref</code>对象拥有一个指向内部值的单一属性 <code>.value</code>.</p><pre><code class="js">const count = ref(0);console.log(count.value); //0count.value++;console.log(count.value); //1</code></pre><p>如果传入<code>ref</code>的是一个对象,将调用 <code>reactive</code> 方法进行深层次响应式转换.</p><ul><li><p><strong>模板中访问</strong><br>当 <code>ref</code> 作为渲染上下文的属性返回（即在 <code>setup()</code> 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 <code>.value</code></p><pre><code class="js">&lt;template&gt;  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    setup() &#123;      return &#123;        count: ref(0),      &#125;;    &#125;,  &#125;;&lt;/script&gt;</code></pre></li><li><p><strong>作为响应式对象的属性访问</strong><br>当 <code>ref</code> 作为 <code>reactive</code> 对象的 <code>property</code> 被访问或修改时,也将自动解套 <code>value</code> 值,其行为类似于普通属性.</p></li></ul><pre><code class="js">const count = ref(0);const state = reactive(&#123;  count,&#125;);console.log(state.count); // 0state.count = 1;consoe.log(count.value); // 1</code></pre><blockquote><p>注意: 当嵌套再 <code>reactive object</code> 中时,<code>ref</code>才会解套. 从<code>array</code>,<code>Map</code> 等原生集合类中访问 <code>ref</code> 时,不会自动解套.</p></blockquote><pre><code class="js">const arr = reactive([ref(0)]);// 这里需要 .valueconsole.log(arr[0].value);const map = reactive(new Map([[&quot;foo&quot;, ref(0)]]));// 这里需要 .valueconsole.log(map.get(&quot;foo&quot;).value);</code></pre><ul><li><strong>类型定义</strong></li></ul><pre><code class="ts">interface Ref&lt;T&gt; &#123;  value: T;&#125;function ref&lt;T&gt;(value: T): Ref&lt;T&gt;;</code></pre><h5 id="computed"><a href="#computed" class="headerlink" title="computed"></a><strong><code>computed</code></strong></h5><ul><li>传入一个 <code>getter</code> 函数,返回一个默认不可修改的 <code>ref</code> 对象.</li></ul><pre><code class="js">const count = ref(0);const plusOne = computed(() =&gt; count.value + 1);</code></pre><ul><li>传入一个拥有 get 和 set 函数的对象,创建一个可以手动修改的计算状态.</li></ul><pre><code class="js">const count = ref(1);const plusOne = computed(&#123;  get: () =&gt; &#123;    return count.value + 1;  &#125;,  set: (val) =&gt; &#123;    count.value = val + 1;  &#125;,&#125;);</code></pre><ul><li>类型定义</li></ul><pre><code class="ts">// 只读类型function computed&lt;T&gt;(getter: () =&gt; T): Readonly&lt;Ref&lt;Readyonly&lt;T&gt;&gt;&gt;;// 可更改function computed&lt;T&gt;(options: &#123;  get: () =&gt; T;  set: (value: T) =&gt; volid;&#125;): Ref&lt;T&gt;;</code></pre><h5 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><code>readonly</code></h5><p>传入一个对象(响应式或普通),返回一个原始对象的深层次只读代理.对象内部任何嵌套的属性也都是只读的.</p><pre><code class="js">const original = reactive(&#123; count: 0 &#125;);const copy = readonly(original);watchEffect(() =&gt; &#123;  // 依赖追踪  console.log(copy.count);&#125;);// original 上的修改会触发 copy 上的侦听original.count++;// 无法修改 copy 并会被警告copy.count++; // warning!</code></pre><h5 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a><code>watchEffect</code></h5><p>立即执行传入的一个函数,并响应式追踪其依赖,并在其依赖变更时重新运行该函数.</p><pre><code class="js">const count = ref(0);watchEffect(() =&gt; &#123;  console.log(count.value);&#125;);</code></pre><ul><li>停止侦听<br>当 <code>watchEffect</code> 在组件的 <code>setup()</code> 函数或者生命周期钩子被调用时,侦听器会被链接到该组件的生命周期,并在组件卸载的时候自动停止.</li></ul><p>在一些情况下,也可以显式调用返回值以停止侦听.</p><pre><code class="js">const stop = watchEffect(() =&gt; &#123;  /* ... */&#125;);stop();</code></pre><ul><li><p>清除副作用</p><p>有时候 <code>watchEffect</code> 函数 会执行一些异步响应，这些响应需要在其失效时清除（异步操作完成之前状态发生改变）。<br>所以<code>watchEffect</code> 接收 <code>onInvalidate</code> 函数作为入参，用来注册清除失效的异步响应。<br><code>onInvalidate</code>函数触发时机：</p><ul><li><code>watchEffect</code>重新执行。</li><li>侦听器被停止（如果在 <code>setup()</code> 或 生命周期钩子函数中使用了 <code>watchEffect</code>, 则在卸载组件时）</li></ul><pre><code class="js">watchEffect((&#123; onInvalidate &#125;) =&gt; &#123;  const token = performAsyncOperation(id.value);  onInvalidate(() =&gt; &#123;    // id 改变时 或 停止侦听时    // 取消之前的异步操作    token.cancel();  &#125;);&#125;);</code></pre></li><li><p>副作用刷新时机</p><p>Vue 的响应式系统会缓存副作用函数，并异步的刷新，这样可以避免同一个 tick 中多个状态导致的不必要重复调用。<br>在核心的具体实现中，组件的更新函数也是一个被侦听的副作用。 当一个用户定义的副作用进入队列时，会在所有的组件更新完成之后执行。</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    setup() &#123;      const count = ref(0);      watchEffect(() =&gt; &#123;        console.log(count.value);      &#125;);      return &#123;        count,      &#125;;    &#125;,  &#125;;&lt;/script&gt;</code></pre><p>在这个栗子中：</p><ul><li><code>count</code> 会在初始化运行时同步打印出来。</li><li>更改 <code>count</code> 时，将在组件<strong>更新后</strong>执行副作用。</li></ul></li></ul><p>需要注意的是，初始化运行实在组件 <code>mounted</code> 之前执行的，所以，编写副作用函数时希望文档 DOM（或者模板 ref），需要在 <code>onMounted</code> 钩子中进行。</p><pre><code class="js"> onMounted()&#123;   watchEffect(()=&gt;&#123;      // 这里可以访问 DOM 或者 template refs   &#125;) &#125;</code></pre><p>如果副作用需要同步或在组件更新之前重新运行，我们可以传递一个拥有 <code>flush</code> 属性的对象作为选项（默认为 <code>post</code> ）</p><pre><code class="js">  onMounted()&#123;   // 同步运行。   watchEffect(()=&gt;&#123;      // do something   &#125;,   &#123;     flush:&#39;sync&#39;   &#125;)   // 组件更新之前执行。   watchEffect(()=&gt;&#123;       // do something   &#125;,   &#123;     flush:&#39;pre&#39;   &#125;) &#125;</code></pre><h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a><code>watch</code></h5><p><code>watch</code> API 完全等效于 2.x 的 <code>this.$watch</code>。 <code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用函数。 默认情况下是懒执行的，也就是仅在侦听源变更时在会执行回调。</p><ul><li><p>对比 <code>watchEffect</code> , <code>watch</code>允许我们：</p><ul><li>懒加载执行副作用。</li><li>更明确拿些状态的改变会触发侦听器重新运行副作用。</li><li>访问侦听状态变化前后的值。</li></ul></li><li><p>侦听单个数据源<br>侦听器的数据源可以时一个拥有返回值的<code>getter</code>函数,也可以时 ref 对象：</p><pre><code class="js">// 侦听一个getterconst state = reactive(&#123;  count: 0,&#125;);watch(  () =&gt; state.count,  (count, prevCount) =&gt; &#123;&#125;);// 侦听一个ref// 直接侦听一个 refconst count = ref(0);watch(count, (count, prevCount) =&gt; &#123;  /* ... */&#125;);</code></pre></li><li><p>侦听多个数据源</p><p><code>watcher</code> 也可以使用数组来同时侦听多个数据源。</p><pre><code class="js">watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; &#123;  /* ... */&#125;);</code></pre></li><li><p>与 <code>watchEffect</code> 共享的行为<br><code>watch</code> 和 <code>watchEffect</code> 在停止侦听, 清除副作用 (相应地 <code>onInvalidate</code> 会作为回调的第三个参数传入)，副作用刷新时机 和 侦听器调试 等方面行为一致.</p></li></ul><h4 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/tree.png&quot; alt=&quot;tree&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;setup&quot;&gt;&lt;a href=&quot;#setup&quot; class=&quot;headerlink&quot; title=&quot;setup&quot;&gt;&lt;/a&gt;setup&lt;/h4&gt;&lt;p&gt;&lt;code&gt;setup</summary>
      
    
    
    
    <category term="VUE3" scheme="https://heybigfish.github.io/categories/VUE3/"/>
    
    
    <category term="基础" scheme="https://heybigfish.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-构造函数及继承</title>
    <link href="https://heybigfish.github.io/2021/08/02/JavaScript-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E7%BB%A7%E6%89%BF/"/>
    <id>https://heybigfish.github.io/2021/08/02/JavaScript-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E7%BB%A7%E6%89%BF/</id>
    <published>2021-08-02T10:13:44.000Z</published>
    <updated>2021-08-20T02:57:08.139Z</updated>
    
    <content type="html"><![CDATA[<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>JavaScript 中存在 2 种函数，即普通函数和构造函数，两者结构相同，但是用法不同。<br>为了在形式意义上区分，构造函数习惯上首字母大写，普通函数则首字母小写。</p><ul><li><p>普通函数，简单来说就是封装代码块，实现代码块的复用。</p></li><li><p>构造函数<br>当你需要大批量的创建对象的时候，就需要用到构造函数，它可以方便创建多个对象的实例，并且创建的对象可以被标识为特定的类型，可以通过继承扩展代码<br>结构和普通函数没有区别，习惯上函数名称首字母大写，调用时使用关键字 <strong>new</strong> 进行调用。<br>创建一个简单的构造函数</p><pre><code class="js">function People(name,sex)&#123;  // 第一个阶段(隐式)  // var this = &#123;&#125;;  // 第二个阶段  this.country= &#39;China&#39;;  this.name = name;  this.sex = sex;  // 第三个阶段 (隐式)  // return this;  &#125;  var xiaowang = new People(&#39;小王&#39;,&#39;male&#39;);  var xiaohong = new People(&#39;小红&#39;,&#39;girl&#39;);`</code></pre></li></ul><p>使用 new 操作符调用构造函数时，会经历三个阶段</p><ol><li>创建一个新对象：首先在当前形成的私有栈中创建一个对象（创建一个空的堆内存），并且让函数中的执行主体（this）指向这个新的堆内存(新对象);</li><li>执行构造函数代码块;</li><li>返回新对象;</li></ol><p>这里的构造函数 <code>People</code> 批量的产生了 <code>xiaohong</code> 和 <code>xiaowang</code> 两个对象。</p><p>有个不太好的地方，那就是对于每一个实例对象，<code>country</code> 属性都是一模一样的内容，每生成一个实例，都必须生成相同的属性内存，大量重复的内容，会造成不必要的性能消耗以及内存泄漏。</p><p>有没有办法让这些不需要每次都改变的值仅生成，然后所有实例都指向那个内存地址呢？这里就需要考虑使用构造函数的<strong>继承</strong></p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li><p>prototype 模式<br><code>JavaScript</code> 规定，每一个构造函数都有一个 <code>prototype</code> 属性，指向另一个对象(该构造函数生成的实例对象的<strong>proto</strong>对象)。</p><p>这个对象的所有属性和方法，都会被构造函数的实例继承。可以把这些不需要改动的属性挂载到 <code>prototype</code> 指向的对象，是不是可以达到继承的目的？</p><pre><code class="js">function People(name, sex) &#123;  this.name = name;  this.sex = sex;&#125;People.prototype.country = &quot;China&quot;;var xiaowang = new People(&quot;小王&quot;, &quot;male&quot;);var xiaohong = new People(&quot;小红&quot;, &quot;girl&quot;);xiaowang.country; //&#39;Chinaxiaohong.country; //&#39;China&#39;</code></pre><p>这时所有实例的 country 属性其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。<br>既然这里的实例对象都是由同一个构造函数制造出来的，Javascript 定义了一些辅助方法，帮助我们找到实例对象的和构造函数的一些联系</p><pre><code></code></pre></li><li><p>isPrototypeOf()<br>这个方法帮助我们判断某个 proptotype 对象和某个实例之间的关系<br><code>console.log(xiaohong.prototype.isPrototypeOf(People)); //true 等同于xiaowang.__proto__.constructor.name</code></p></li><li><p>hasOwnProperty()<br>每个实例对象都有一个 hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自 prototype 对象的属性<br><code>console.log(xiaohong.hasOwnProperty(name)); //true console.log(xiaohong.hasOwnProperty(country)); //false</code></p></li></ul><h5 id="call-或-apply-方法"><a href="#call-或-apply-方法" class="headerlink" title="call 或 apply 方法"></a>call 或 apply 方法</h5><p>使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</p><pre><code>     function Country()&#123;         this.country = &#39;China&#39;;     &#125;     function People(name,sex)&#123;         Country.apply(this, arguments);         this.name = name;         this.sex = sex;     &#125;     var xiaowang = new People(&quot;小王&quot;,&quot;男&quot;);     console.log(xiaowang.country);  //&#39;China&#39;</code></pre><h5 id="Prototype-模式改进方法"><a href="#Prototype-模式改进方法" class="headerlink" title="Prototype 模式改进方法"></a>Prototype 模式改进方法</h5><p>这个方法与之前相比，忽略了执行和创建 Country 的过程，有了一定的效率优化。</p><pre><code>      function Country()&#123;&#125;;      Country.prototype.country = &#39;China&#39;;      function People(name,sex)&#123;          this.name = name;          this.sex = sex;      &#125;      People.prototype = Country.prototype;      People.prototype.constructor = People;      //由于复制了Country的prototype属性，所有这时候constructor指向了Country构造函数，为了正确的描述constructor指向，手动修改。</code></pre><p>存在一个问题，由于 JavaScript 中，对象为引用类型的值，导致 People 和 Country 的 prototype 属性指向了同一个内存地址，修改 People 的 prototype 属性同时也会导致 Country 的 prototype 属性的被动修改。</p><p>为了优化这个问题,可以通过 Obiect 的 assign()方法进行深拷贝，同时复制一个新的内存地址，使 People 的修改不会影响 Country 的 prototype 属性。</p><pre><code>   //People.prototype = Country.prototype; 可以做一下修改   People.prototype = Object.assign(&#123;&#125;,Country.prototype);</code></pre><h4 id="利用空对象作为媒介"><a href="#利用空对象作为媒介" class="headerlink" title="利用空对象作为媒介"></a>利用空对象作为媒介</h4><p>利用一个空对象作为媒介，也可以很好的完成继承的功能</p><pre><code>  var F = function()&#123;&#125;;  F.prototype = Country.prototype;  People.prototype = new F();  People.prototype.constructor = People;</code></pre><p>new F()实例生成了一个新的对象，使 People 的 prototype 和 Country 的 prototype 进行内存地址的隔离，也能很好的处理上一个方法中产生的问题。</p><p>基于这个实现过程，现在封装一个函数，便以使用。</p><pre><code>    function extend(Child,Parent)&#123;        var F = function()&#123;&#125;;        F.prototype = Parent.prototype;        Child.prototype = new F();        Child.prototype.constructor = Child;    &#125;</code></pre><p>使用时，直接调用封装好的函数</p><pre><code>extend( People,Country);var xiaohong = new People(&#39;小红&#39;,&#39;女&#39;);console.log(xiaohong.country);  //&#39;China&#39;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h5&gt;&lt;p&gt;JavaScript 中存在 2 种函数，即普通函数和构造函数，两者结构相同，但是用法不同。&lt;br&gt;为了在形式意义上区分，构造函数习惯上首字</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://heybigfish.github.io/categories/JavaScript/"/>
    
    
    <category term="基础" scheme="https://heybigfish.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-类型转换</title>
    <link href="https://heybigfish.github.io/2021/08/02/JavaScript-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://heybigfish.github.io/2021/08/02/JavaScript-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-08-02T10:02:07.000Z</published>
    <updated>2021-08-20T02:57:08.140Z</updated>
    
    <content type="html"><![CDATA[<h6 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h6><ul><li><p><code>Number(mix)</code>;<br>将 mix 转化为数字类型，true 转化为 1，false 转化为 0，比较特殊一点的是，undefined 与其他 false 值(null,)不同,不能转化为 0，只能只能转化为 NAN</p><pre><code class="js">var a = &quot;123&quot;;Number(a); // 123var b = true;Number(b); // 1var c = false || null;Number(c); // 0var d = undefined;Number(d); // NANvar e = &quot;123abc&quot;;Number(e); // NAN `</code></pre></li><li><p><code>parseInt(string,radix)</code>;<br>将 string 转化为数字整型,以 string 首位开始查询数字，直到非数字截至，然后返回。<br>radix 参数为源数据进制，即将数据源以 radix 进制进行解析，然后返回 10 进制数值。</p><pre><code class="js">var a = &quot;123.111&quot;;parseInt(a); // 123var b = true || false;parseInt(b); // NANvar c = 11;parseInt(c, 2); // 3</code></pre></li><li><p><code>parsetFloat(string)</code><br>将 string 转化为数字浮点型，以 string 首位开始查询数字，忽略第一个小数点，直到非数字位截至。</p><pre><code class="js">var a = &quot;123.111.222&quot;;parsetFloat(a); // 123.111</code></pre></li><li><p><code>String(str)</code><br>将 str 转化为字符串类型。</p></li><li><p><code>Boolean(str)</code><br>将 str 转化为布尔值。</p></li><li><p><code>toString(radix)</code></p><ul><li>将目标转化为字符串，undefined/null 不能进行转换。</li><li>将目标值转化为 radix 进制的数字，然后返回字符串。<pre><code class="js">var a = 123;a.toString(); // &#39;123‘var b = 10;b.toString(8); // &#39;12`</code></pre><strong>注意，必须是变量才会有这个方法</strong>, 123.toString();会报错。</li></ul></li></ul><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><ul><li><p>isNaN(str)<br>将 str 隐式的进行 Number(str),然后再进行 isNaN()的操作。</p></li><li><p>++，–，+/-(一元正负);<br>str++,将 str 隐式的进行 Number(str),然后再进行运算操作。</p></li><li><p>+加号<br>加号左右两侧，出现字符串，则隐式的将两侧的类型全转换为字符串(String())<br><code>var a = 1+&#39;1&#39;; console.log(a); //&#39;11&#39;</code></p></li><li><p>*, /, %(乘除余);</p><p>出现乘除余的运算，则两侧的类型全转换为数字类型(Number()),然后进行运算。</p></li><li><p>&amp;&amp;,||,!\n 逻辑运算符，两侧隐式的转换为布尔值(Boolean())，然后进行判断。</p></li><li><p>&lt;,&gt;,&lt;=,&gt;=\n 逻辑运算符，两侧隐式的转换为数字类型(Number()),然后进行判断。</p></li><li><p>==,!=<br>两侧先进行类型同化，然后进行判断，出现数字时，均转化为数字(Number())，然后进行比较。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;显式类型转换&quot;&gt;&lt;a href=&quot;#显式类型转换&quot; class=&quot;headerlink&quot; title=&quot;显式类型转换&quot;&gt;&lt;/a&gt;显式类型转换&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Number(mix)&lt;/code&gt;;&lt;br&gt;将 mix 转化为数字类型，tr</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://heybigfish.github.io/categories/JavaScript/"/>
    
    
    <category term="基础" scheme="https://heybigfish.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-闭包</title>
    <link href="https://heybigfish.github.io/2021/08/02/JavaScript-%E9%97%AD%E5%8C%85/"/>
    <id>https://heybigfish.github.io/2021/08/02/JavaScript-%E9%97%AD%E5%8C%85/</id>
    <published>2021-08-02T03:24:29.000Z</published>
    <updated>2021-08-20T02:57:08.142Z</updated>
    
    <content type="html"><![CDATA[<h5 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h5><p>理解闭包，需要先理解 <code>js</code> 的变量作用域，即<strong>全局变量</strong>和<strong>局部变量</strong><br>函数内部可以直接读取全局变量，函数外部则不能读取函数内部的局部变量。<br>函数的局部变量是在函数作用域内进行工作的，为了使用函数内部的局部变量，那么可以在函数内部定义一个内部函数，这个内部函数天然可以读取外层函数的局部变量。</p><pre><code class="js">function bar() &#123;  var name = &quot;a&quot;;  function foo() &#123;    console.log(name);  &#125;&#125;</code></pre><p>这里就涉及到了 <code>js</code> 特有的链式作用域，函数 <code>foo</code> 会一层一层的向外查找所有父级对象的元素，反之则不行，既然函数 <code>foo</code> 能使用函数 <code>bar</code> 的局部变量，那么，我们把 <code>foo</code> 函数 <code>return</code> 出去，那么就可以在函数外部使用函数内部的局部变量！</p><pre><code class="js">function bar() &#123;  var name = &quot;a&quot;;  function foo() &#123;    console.log(name);  &#125;  return foo();&#125;var fc = bar();fc(); //&#39;a&#39;</code></pre><p>这里其实就是闭包。</p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p><strong>「函数」和「函数内部能访问到的变量」的总和，就是一个闭包</strong><br>简单的说也就是一个能够读取到一个函数的局部变量的函数和读取的这个局部变量共同构成闭包。</p><p>从结构上来讲，闭包就是父级函数内部定义一个子函数，该子函数可以读取到父级函数的所有局部变量，构成闭包，子函数是否被 return 出去和闭包没有关系，return 出去只是为了能够正常的使用闭包。</p><h5 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h5><ul><li><p>私有化变量，处于闭包中的局部变量，除了被 return 出去的函数，没有别的途径对其进行访问。</p><blockquote><p>这里又出现了新的问题，由于 js 的垃圾回收机制，会对使用完成或者没有使用的局部变量进行回收，但是在闭包过程中，局部变量一直被 return 出去的函数调用，导致变量始终会储存在内存中。</p></blockquote></li></ul><h5 id="闭包使用过程中存在的问题"><a href="#闭包使用过程中存在的问题" class="headerlink" title="闭包使用过程中存在的问题"></a>闭包使用过程中存在的问题</h5><p>谨慎使用闭包，由于闭包的特殊性，会大量的占用内存。解决方法是，在退出函数之前，将不再使用的局部变量全部删除，或者将使用完成的函数赋值为 null，手动清除内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;变量的作用域&quot;&gt;&lt;a href=&quot;#变量的作用域&quot; class=&quot;headerlink&quot; title=&quot;变量的作用域&quot;&gt;&lt;/a&gt;变量的作用域&lt;/h5&gt;&lt;p&gt;理解闭包，需要先理解 &lt;code&gt;js&lt;/code&gt; 的变量作用域，即&lt;strong&gt;全局变量&lt;/stron</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://heybigfish.github.io/categories/JavaScript/"/>
    
    
    <category term="基础" scheme="https://heybigfish.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript-进阶</title>
    <link href="https://heybigfish.github.io/2021/08/02/TypeScript-%E8%BF%9B%E9%98%B6/"/>
    <id>https://heybigfish.github.io/2021/08/02/TypeScript-%E8%BF%9B%E9%98%B6/</id>
    <published>2021-08-02T03:00:32.000Z</published>
    <updated>2021-08-20T02:57:08.145Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名用来给一个类型起一个新的名字,使用 <code>type</code> 修饰.</p><pre><code class="ts">type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(name: NameOrResolver): void &#123;  if (typeof n === &quot;string&quot;) &#123;    return n;  &#125; else &#123;    return n();  &#125;&#125;</code></pre><p>类型别名常用于联合类型.</p><h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个.</p><pre><code class="ts">type EventNames = &quot;click&quot; | &quot;scroll&quot; | &quot;mousemove&quot;;function handleEvent(ele: Element, event: EventNames) &#123;  // do something&#125;handleEvent(document.getElementById(&quot;hello&quot;), &quot;scroll&quot;); // 没问题handleEvent(document.getElementById(&quot;world&quot;), &quot;dblclick&quot;); // 报错，event 不能为 &#39;dblclick&#39;</code></pre><p>上例中使用了<code>type</code>定了一个字符串字面量类型<code>EventNames</code>,它只能取三种字符串中的一种.</p><blockquote><p><strong>类型别名</strong>和<strong>字符串字面量类型</strong>都是使用<code>type</code>定义的.</p></blockquote><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>数组合并了相同类型的对象,而元组合并了不同类型的对象.<br>简单的栗子</p><pre><code class="ts">let boy: [string, number] = [&quot;tom&quot;, 20];</code></pre><p>可以访问,赋值正确类型的值,添加越界元素时,它的类型会被限制为元组中每个类型的联合类型.</p><pre><code class="ts">let boy: [string, number];boy = [&quot;tom&quot;, 20];boy.push(&quot;male&quot;); //successboy.push(true); //error,Argument of type &#39;true&#39; is not assignable to parameter of type &#39;string | number&#39;.</code></pre><p>因此使用元祖可以确定元素数据类型，但不要超出范围，可以把元祖理解为固定长度，超出范围不能保证其类型。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举类型用于取值被限定在一定范围内的场景,比如一周只能是 7 天.<br>简单的例子<br>枚举使用<code>enum</code>关键字来定义.</p><pre><code class="ts">enum Days &#123;  Sun,  Mon,  Tue,  Wed,  Thu,  Fri,  Sat,&#125;</code></pre><p>枚举成员会被从<code>0</code>开始递增的数字进行赋值,同时也会对枚举名进行反向映射.</p><pre><code class="ts">enum Days &#123;  Sun,  Mon,  Tue,  Wed,  Thu,  Fri,  Sat,&#125;console.log(Days[0] === &quot;sun&quot;); //trueconsole.log(Days[&quot;Sun&quot;] === 0); //true</code></pre><h5 id="手动赋值"><a href="#手动赋值" class="headerlink" title="手动赋值"></a>手动赋值</h5><p>可以给枚举手动赋值:</p><pre><code class="ts">enum Days &#123;  Sun = 3,  Mon = 2,  Tue,  Wed,  Thu,  Fri,  Sat,&#125;console.log(Days[&quot;Sun&quot;] === 3); // trueconsole.log(Days[&quot;Mon&quot;] === 2); // trueconsole.log(Days[&quot;Tue&quot;] === 3); // trueconsole.log(Days[&quot;Sat&quot;] === 7); // true</code></pre><p>未手动赋值的枚举项会接着上一个枚举项递增,递增步长为 <strong>1</strong>。<br>如果未手动赋值的枚举项与手动赋值重复, <code>TypeScript</code> 不会察觉到这一点.</p><pre><code class="ts">enum Days &#123;  Sun = 3,  Mon = 1,  Tue,  Wed,  Thu,  Fri,  Sat,&#125;console.log(Days[&quot;Sun&quot;] === 3); // trueconsole.log(Days[&quot;Wed&quot;] === 3); // trueconsole.log(Days[3] === &quot;Sun&quot;); // falseconsole.log(Days[3] === &quot;Wed&quot;); // true 覆盖掉前一个值.</code></pre><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>传统方法中, <code>JavaScript</code> 通过构造函数类实现类的概念,通过原型链实现继承.<br><code>ES6</code> 中使用 <code>Class</code> 实现这些功能.</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul><li>类(Class):定义一件事物的抽象特点,包含它的属性和方法.</li><li>对象(Object):类的实例,通过<code>new</code>生成.</li><li>面向对象(OOP)的三大特性:封装、继承、多态.<ul><li>封装: 将对数据的操作细节隐藏起来,只暴露对外的接口.实现黑匣子模型,通过对外提供的接口来访问该对象,同时也保证了外界无法任意更改对象内部的数据.</li><li>继承: 子类继承父类,子类除了拥有父类的所有特征外,还有一些更具体的特性.</li><li>多态: 由继承而产生了相关的不同的类,对同一个方法可以有不同的响应.</li></ul></li><li>存取器: 用以改变属性的读取和赋值行为.</li><li>修饰器: 修饰器是一些关键字,用于限定成员或者类型的性质.</li><li>抽象类: 抽象类是供其他类继承的基类,抽象类不允许被实例化.抽象类中的抽象方法必须在子类中被实现.</li><li>接口: 不同的类之间公有的属性或者方法,可以抽象为一个接口.接口可以被类实现.一个类只能继承自另一个类,但是可以实现多个接口.</li></ul><h5 id="ES6-中的用法"><a href="#ES6-中的用法" class="headerlink" title="ES6 中的用法"></a>ES6 中的用法</h5><h6 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h6><p>使用 <code>Class</code> 定义类,使用 <code>constructor</code> 定义构造函数.<br>通过 <code>new</code> 来生成实例时,会自动调用构造函数.</p><pre><code class="ts">class Animal &#123;  public name;  constructor(name) &#123;    this.name = name;  &#125;  sayHi() &#123;    return `My name is $&#123;this.name&#125;`;  &#125;&#125;let cat = new Animal(&quot;cherry&quot;);console.log(cat.sayHi());</code></pre><h6 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h6><p>使用 <code>extends</code> 关键字实现继承,子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法.</p><pre><code class="ts">class Cat extends Animal &#123;  constructor(name, color) &#123;    super(name); // 调用父类的constructor(name)    this.color = color;  &#125;  sayHi() &#123;    return &quot;cat,&quot; + super.sayHi(); // 调用父类的sayHi();  &#125;&#125;</code></pre><h6 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h6><p>使用 <code>getter</code> 和 <code>setter</code> 可以改变属性的赋值和读取行为:</p><pre><code class="ts">class Animal &#123;  constructor(name) &#123;    this.name = name;  &#125;  get name() &#123;    return &quot;getter&quot;;  &#125;  set name(value) &#123;    console.log(&quot;setter: &quot; + value);  &#125;&#125;let a = new Animal(&quot;Kitty&quot;); // setter: Kittya.name = &quot;Tom&quot;; // setter: Tomconsole.log(a.name); // Jack</code></pre><h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><p>使用 <code>static</code> 修饰符修饰的方法称为静态方法,他们不需要实例化,而是通过类来直接调用;</p><pre><code class="ts">class Animal &#123;  static isAnimal(a) &#123;    return a instanceof Animal;  &#125;&#125;let cat = new Animal(&quot;jack&quot;);cat.isAnimal(a); // TypeError: a.isAnimal is not a functionAnimal.isAnimal(a); // true</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;类型别名&quot;&gt;&lt;a href=&quot;#类型别名&quot; class=&quot;headerlink&quot; title=&quot;类型别名&quot;&gt;&lt;/a&gt;类型别名&lt;/h4&gt;&lt;p&gt;类型别名用来给一个类型起一个新的名字,使用 &lt;code&gt;type&lt;/code&gt; 修饰.&lt;/p&gt;
&lt;pre&gt;&lt;code cla</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://heybigfish.github.io/categories/TypeScript/"/>
    
    
    <category term="进阶" scheme="https://heybigfish.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript-基础</title>
    <link href="https://heybigfish.github.io/2021/07/19/TypeScript-%E5%9F%BA%E7%A1%80/"/>
    <id>https://heybigfish.github.io/2021/07/19/TypeScript-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-19T03:43:54.000Z</published>
    <updated>2021-08-20T02:57:08.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JavaScript 的特性</strong></p><ul><li>它没有类型约束，一个变量可能初始化时是字符串，又被赋值为数字。</li><li>存在大量的隐式转换，变量类型难以确定。</li><li>原型上的属性或方法可以在运行时被修改。</li><li>解释性语言，没有编译阶段，属于动态类型。（运行时报错）</li></ul><p><strong>TypeScript 的特性</strong></p><ul><li>TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。</li><li>静态类型，「类型」是 TypeScript 最核心的特性，运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查。</li><li>弱类型，完全兼容 JavaScript ，不会修改 JavaScript 运行时的特性。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>布尔值时最基础的数据类型。</p><pre><code class="ts">let show: boolean = false;// 编译通过</code></pre><p>需要注意的是，构造函数 <code>Boolean</code> 创造的是一个 <code>Boolean</code> 对象,并不是布尔值。</p><pre><code class="ts">let createBoolean: Boolean = new Boolean(true);//  Boolean &#123;true&#125;</code></pre><p>直接调用会 <code>Boolean</code> 则可以返回 <code>boolean</code> 值。</p><pre><code class="ts">let createBoolean: boolean = Boolean(true);// true</code></pre><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><pre><code class="ts">let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code class="ts">let name: string = &quot;Tree&quot;;</code></pre><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p><code>JavaScript</code> 没有空值(Viid)的概念，在 <code>TypeScript</code> 中，可以使用 <code>void</code> 表示没有任何返回值的函数：</p><pre><code class="ts">function count(): void &#123;  let num: number = 0;  num++;&#125;</code></pre><p>声明没有返回值函数存在意义，声明 <code>void</code> 变量则没有意义，只能将它赋值给 <code>undefined</code> 和 <code>null</code></p><pre><code class="ts">let unusable: void = undefined;let unvalue: void = null;</code></pre><h4 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h4><p>在 <code>TypeScript</code> 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p><pre><code class="ts">let u: undefined = undefined;let n: null = null;</code></pre><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 <strong>任意</strong> 类型的变量：</p><pre><code class="ts">// 这样不会报错let num: number = undefined;</code></pre><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p>普通类型，在赋值过程中改变类型是不被允许的，。<br>如果是 <code>any</code> 类型，则允许被赋值为<strong>任意类型</strong>，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p><p>任意值上访问任何熟悉都是允许的。</p><pre><code class="ts">let number: string = &quot;1&quot;;number = 1;let anyThing: any = &quot;hello&quot;;console.log(anyThing.number);console.log(anyThing.number.age);</code></pre><p>也允许调用任何方法：</p><pre><code class="ts">let anyThing: any = &quot;sleep&quot;;anyThing.time(&quot;1000&quot;);anyThing.time(&quot;1000&quot;).do();</code></pre><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong></p><pre><code class="ts">let something;something = &quot;1&quot;;something = 1;</code></pre><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p><code>TypeScript</code> 会在没有明确的指定类型的时候,根据赋值推测出一个类型。<br>如果定义的时候没有赋值，都会被推断成 any 类型而完全不被类型检查</p><pre><code class="ts">let num;num = &quot;7&quot;;num = 7;</code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型,表示取值可以为多种类型中的一种。</p><pre><code class="ts">let num: number | string;num = &quot;1&quot;;num = 1;</code></pre><p><strong>访问联合类型的属性或方法</strong><br>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p><pre><code class="ts">function getLength(e: string | number) &#123;  return e.length;&#125;// 编译失败。</code></pre><p><code>length</code> 不是<code>number</code>和<code>string</code>的共有属性，所以会报错。</p><pre><code class="ts">function toString(e: string | number) &#123;  return e.toString();&#125;// 编译成功，toString() 是共有属性。</code></pre><p>当联合类型的变量在赋值的时候，会根据类型推断出一个类型。</p><pre><code class="ts">let num: string | number;num = &quot;1&quot;;console.log(num.length); // 编译成功，类型推断为 string，访问length成功。num = 1;console.log(num.length); // 编译报错，类型推断为 number，访问length失败。</code></pre><h3 id="对象的类型-接口-Interfaces"><a href="#对象的类型-接口-Interfaces" class="headerlink" title="对象的类型 - 接口 (Interfaces)"></a>对象的类型 - 接口 (Interfaces)</h3><p>在 <code>TypeScript</code> 中，使用接口来定义对象的类型，结构。</p><pre><code class="ts">interface Person &#123;  name: string;  age: number;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  age: 25,&#125;;</code></pre><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p><p><strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong><br>对象定义的变量比接口少或者多一些属性是不允许的。</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,&#125;;let Jenny: Person = &#123;  name: &quot;Jenny&quot;,  age: 21,&#125;;</code></pre><p>使用<code>?</code>修饰的变量，可以不存在，但是 <strong>仍然不允许添加未定义的属性。</strong></p><h4 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h4><p>如果希望接口中允许存在任意属性的变量，可以使用<code>[propName: string]: any]</code> 进行修饰。</p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;  [propName: string]: any;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  gender: &quot;male&quot;,&#125;;</code></pre><p>注意：<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</strong></p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;  [propName: string]: string;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  age: 25,  gender: &quot;male&quot;,&#125;;//  编译失败</code></pre><p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p><p>可以使用联合类型进行处理：</p><pre><code class="ts">interface Person &#123;  name: string;  age?: number;  [propName: string]: string | number;&#125;let tom: Person = &#123;  name: &quot;Tom&quot;,  age: 25,  gender: &quot;male&quot;,&#125;;</code></pre><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>如果希望对象中的部分属性，只能在被创建的时候被赋值，且不能被修改， 可以使用 <code>readonly</code> 进行修饰属性。</p><pre><code class="ts">interface Person &#123;  readonly id: number;  name: string;  age?: number;  [propName: string]: any;&#125;let tom: Person = &#123;  id: 9527,  name: &quot;Tom&quot;,  age: 21,  gender: &quot;male&quot;,&#125;;tom.id = 123; // 编译报错，id为只读属性。</code></pre><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><p>在 TypeScript 中，数组的类型有多种定义方式。</p><h4 id="「类型-方括号」"><a href="#「类型-方括号」" class="headerlink" title="「类型 + 方括号」"></a>「类型 + 方括号」</h4><p>最简单、直观的一种方式。</p><pre><code class="ts">let arr: number[] = [1, 2, 3, 4, 5];</code></pre><p>上例中，数组中的每一项都必须是 <code>number</code> 类型。</p><h4 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h4><p>使用数组泛型来定义数组类型</p><pre><code class="ts">let nums: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre><h4 id="接口表示数组"><a href="#接口表示数组" class="headerlink" title="接口表示数组"></a>接口表示数组</h4><p>数组是对象，使用接口定义数组类型。</p><pre><code class="ts">interface NumberArray &#123;  [index: number]: number;&#125;let nums: NumberArray = [1, 1, 2, 3, 5];</code></pre><h4 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h4><p>类数组不是普通的数组，只能使用接口进行描述。<br>以 <code>arguments</code> 为例。</p><pre><code class="ts">function count() &#123;  let args: &#123;    [index: number]: number;    length: number;    callee: Function;  &#125; = arguments;&#125;</code></pre><p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p><pre><code class="ts">function count() &#123;  let args: IArguments = arguments;&#125;</code></pre><p>其中 <code>IArguments</code> 是 TypeScript 中定义好的内容。 等价于下例。</p><pre><code class="ts">interface IArguments &#123;  [index: number]: number;  length: number;  callee: Function;&#125;</code></pre><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束。</p><pre><code class="ts">function count(x: number, y: number): number &#123;  return x + y;&#125;</code></pre><p><strong>输入不符合约束或者输出约束的输出，都是不被允许的。</strong></p><pre><code class="ts">let count = function (x: number, y: number): number &#123;  return x + y;&#125;;</code></pre><p>上例中只是对右侧的函数进行了类型定义，左侧的变量是通过类型推论而推断出了类型定义。</p><p>完整示例：</p><pre><code class="ts">let count: (x: number, y: number) =&gt; number = function (  x: number,  y: number): number &#123;  return x + y;&#125;;</code></pre><ul><li>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的返回值。</li><li>在 ES6 中，<code>=&gt;</code> 叫做箭头函数。</li></ul><p>函数是特殊的对象，所以也可以使用接口定义函数类型。</p><pre><code class="ts">interface Nums &#123;  (x: number, y: number): number;&#125;let nums: Nums = function (x: number, y: number): number &#123;  return x + y;&#125;;</code></pre><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>用 <code>?</code> 表示可选的参数。</p><pre><code class="ts">function count(x: number, y: number, z?: number): number &#123;  if (z) &#123;    return x + y + z;  &#125; else &#123;    return x + y;  &#125;&#125;count(1, 2);</code></pre><p>注意,<strong>可选参数必须在必需参数后面</strong> 也就是说，可选参数后面不允许在出现必选参数。</p><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>ES6 中对函数的参数添加了默认值，在 TypeScript 中，对于添加了默认值的参数，识别为可选参数，且和参数出现顺序无关，不必遵守 【可选参数必须在必需参数后面】。</p><h4 id="剩余参数（rest-参数）"><a href="#剩余参数（rest-参数）" class="headerlink" title="剩余参数（rest 参数）"></a>剩余参数（rest 参数）</h4><p>ES6 中，可以使用 …rest 的方式获取函数中的剩余参数，rest 是一个数组，可以通过数组的类型来定义。</p><pre><code class="ts">function doRest(array: any[], ...items: any[]) &#123;  items.forEach(function (item) &#123;    array.push(item);  &#125;);&#125;let arr = [];doRest(arr, 1, 2, 3);</code></pre><p>注意：<strong>rest 参数只能是最后一个参数</strong></p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载允许一个函数接受不同数量、类型的参数时，做出不同的处理。<br>栗子一：实现 <code>reverse</code> 函数，反转输入的参数。123==&gt; 321; ‘hello’==&gt;’olleh’。</p><pre><code class="ts">function reverse(x: number | string): number | string | void &#123;  if (typeof x === &quot;number&quot;) &#123;    return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;));  &#125; else if (typeof x === &quot;string&quot;) &#123;    return x.split(&quot;&quot;).reverse().join(&quot;&quot;);  &#125;&#125;</code></pre><p>基本实现需求，但是会存在一个问题，函数定义比较模糊，参数为数字时，返回值应该是数字。参数为字符串时，返回值应该是字符串，上例不能很好的处理这个问题。</p><p>借助函数的<strong>重载</strong>可以很好的解决这个问题。</p><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string | void &#123;  if (typeof x === &quot;number&quot;) &#123;    return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;));  &#125; else if (typeof x === &quot;string&quot;) &#123;    return x.split(&quot;&quot;).reverse().join(&quot;&quot;);  &#125;&#125;</code></pre><p>上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p><p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言可以手动的指定一个值的类型。</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p><code>值 as 类型</code> 或者 <code>&lt;类型&gt;值</code> ;</p><p>由于 <code>&lt; &gt;</code> 也有表示泛型的意思，为了避免混淆，建议使用 <code>值 as 类型</code> 的写法进行使用类型断言。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p><strong>将一个联合类型断言为其中一个类型</strong></p><p>当 TypeScript 不确定一个联合类型的变量到底是哪一种时，通常只能访问联合类型中的共有属性或方法。</p><pre><code class="ts">interface Cat &#123;  name: string;  run(): void;&#125;interface Fish &#123;  name: string;  swim(): void;&#125;function getName(something: Cat | Fish): string &#123;  return something.name;&#125;</code></pre><p>有时候，不确定类型的时候就要访问一个类型特有的属性或者方法。</p><pre><code class="ts">interface Cat &#123;  name: string;  run(): void;&#125;interface Fish &#123;  name: string;  swim(): void;&#125;function isCat(something: Cat | Fish): boolean &#123;  if (something.run) &#123;    return true;  &#125;  return false;&#125;</code></pre><p>因为类型 Filsh 没有 run 的属性和方法，所以编译失败.<br>此时可以使用类型断言，将 something 断言为 Cat</p><pre><code class="ts">interface Cat &#123;  name: string;  run(): void;&#125;interface Fish &#123;  name: string;  swim(): void;&#125;function isCat(something: Cat | Fish): boolean &#123;  if ((something as Cat).run) &#123;    return true;  &#125;  return false;&#125;</code></pre><p>类型断言是能够避免编译阶段的报错，不能避免运行时的报错。<br>谨慎使用类型断言，避免产生一些不必要的错误。</p><p><strong>将一个父类断言为具体的子类</strong></p><pre><code class="ts">class Animal &#123;&#125;class Cat extends Animal &#123;  run() &#123;    console.log(&quot;running&quot;);  &#125;&#125;class Brid extends Animal &#123;  fly() &#123;    console.log(&quot;flying&quot;);  &#125;&#125;function doSomething(something: Animal): void &#123;  if ((something as Brid).fly) &#123;    console.log(&quot;this is brid&quot;);  &#125;&#125;</code></pre><p><code>class</code> 实现的类，属于 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 实例与类之间的关系。 [<code>something instanceof Brid</code>]</p><p>一般情况下，Cat 和 Brid 只是一个 TypeScript 的接口，并不是真正意义的值，只是对象的描述信息，编译过程中会被删除，所以不能用 instanceof 进行判断。这时候只能使用 [类型断言] 进行判断。</p><pre><code class="ts">interface Animal &#123;&#125;interface Cat extends Animal &#123;  run() &#123;    console.log(&quot;running&quot;);  &#125;&#125;interface Brid extends Animal &#123;  fly() &#123;    console.log(&quot;flying&quot;);  &#125;&#125;function doSomething(something: Animal): void &#123;  if ((something as Brid).fly) &#123;    console.log(&quot;this is brid&quot;);  &#125;&#125;</code></pre><p><strong>将任何一个类型断言为 <code>any</code></strong></p><p>理想状态下，TypeScript 的类型界定具体，明确，调用类型上不存在的属性和方法时，会报错</p><pre><code class="ts">const foo: number = 1;foo.length = 1;// 类型“number”上不存在属性“length”。ts</code></pre><p>这种报错信息简单而有效。</p><p>但是存在某些情况，非常确信代码不会发生错误。</p><pre><code class="ts">window.foo = 1;// 类型“Window &amp; typeof globalThis”上不存在属性“foo”。</code></pre><p>如果对 window 对象 添加属性 <code>foo</code>, 但是 TypeScript 编译会报错。<br>此时可以使用 <code>as any</code> 临时断言 <code>window</code> 对象为 <code>any</code> 类型。</p><pre><code class="ts">(window as any).foo = 1;</code></pre><p>需要注意的时，将一个变量断言为 <code>any</code> 是 TypeScript 中解决类型问题的最后一个手段。</p><p><strong>将 <code>any</code> 断言为一个具体的类型。</strong></p><p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。<br>我们可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型。</p><pre><code class="ts">function anyAnimal(key: string): any &#123;  let obj = &#123;    name: key,  &#125;;  return obj;&#125;interface Cat &#123;  name: string;  run(): void;&#125;const tom = anyAnimal(&quot;tom&quot;) as Cat;tom.run();</code></pre><p>上例中明确了 tom 的类型为 <code>Cat</code>,对于后续的维护工作比较友好。</p><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>并不是任何一个类型都可以被断言为任何一个类型<br>具体来说 <code>A</code> 兼容（包含） <code>B</code>,那么 <code>A</code> 就能被断言为 <code>B</code>,<code>B</code> 也能被断言为 <code>A</code> 。</p><ul><li>联合类型可以被断言为其中的一个类型。</li><li>父类可以被断言为子类</li><li>子类可以被断言为父类</li></ul><p>举个栗子</p><pre><code class="ts">interface Person &#123;  name: string;&#125;interface Boy &#123;  name: string;  gender: string;&#125;let tom: Boy = &#123;  name: &quot;tom&quot;,  gender: &quot;male&quot;,&#125;;let sonmeone: Person = tom;</code></pre><p>TypeScript 是结构性类型系统，类型之间只会比较他们之间的<strong>最终结构</strong>，会忽略定义时的关系。<br>所以，上例中接口 <code>Boy</code> 拥有接口 <code>Person</code> 中所有的属性，所以 <code>TypeScript</code> 会认为<code>Boy extends Person</code>,即 <code>Boy</code>是<code>Person</code>的子类，所以<br><code>let sonmeone: Person = tom;</code><br><code>Person</code> 被断言为 <code>Boy</code> [父类可以被断言为子类]</p><p>第二个栗子</p><pre><code class="ts">interface Animal &#123;  name: string;&#125;interface Cat &#123;  name: string;  run(): void;&#125;function testAnimal(animal: Animal) &#123;  return animal as Cat;&#125;function testCat(cat: Cat) &#123;  return cat as Animal;&#125;</code></pre><ul><li><code>animal as Cat</code> [父类可以被断言为子类],从类型来讲，父类兼容（包含）子类，父类可以被断言为子类。</li><li><code>cat as Animal</code> [子类可以被断言为父类]，子类拥有父类的所有方法和属性，从内容来讲，子类包含父类，子类可以被断言为父类。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;JavaScript 的特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它没有类型约束，一个变量可能初始化时是字符串，又被赋值为数字。&lt;/li&gt;
&lt;li&gt;存在大量的隐式转换，变量类型难以确定。&lt;/li&gt;
&lt;li&gt;原型上的属性或方法可以在运行时被修改。&lt;/l</summary>
      
    
    
    
    <category term="TypeScript" scheme="https://heybigfish.github.io/categories/TypeScript/"/>
    
    
    <category term="基础" scheme="https://heybigfish.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-this 指向问题</title>
    <link href="https://heybigfish.github.io/2019/01/02/JavaScript-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <id>https://heybigfish.github.io/2019/01/02/JavaScript-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</id>
    <published>2019-01-02T03:12:37.000Z</published>
    <updated>2021-08-20T02:57:08.137Z</updated>
    
    <content type="html"><![CDATA[<h5 id="this-特点"><a href="#this-特点" class="headerlink" title="this 特点"></a>this 特点</h5><p>JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变，所以具有很大的迷惑性。</p><h5 id="this-指向问题"><a href="#this-指向问题" class="headerlink" title="this 指向问题"></a>this 指向问题</h5><p>JavaScript 的 this 指向，简单的来说，我们通常可以理解为 [<strong>谁调用，this 就指向谁</strong>] ,这句话并不严谨，但是可以解释极大多数情况下的 this 指向。</p><ul><li><p>示例一</p><pre><code class="js">var x = &quot;a&quot;;function bar() &#123;  console.log(this.x);&#125;bar(); // &#39;a&#39;</code></pre><p>打印结构为<code>a</code>,即这里的 <code>this</code> 为全局对象，这里调用的 <code>bar()</code>,实际上是 <code>window.bar()</code>; <code>window</code> 也就是全局对象，所以这种情况符合 [<strong>谁调用，this 就指向谁</strong>] 这句话。</p></li><li><p>示例二</p><pre><code class="js">b = &quot;1&quot;;var a = &#123;  b: &quot;0&quot;,  bar: function () &#123;    console.log(this.b);  &#125;,&#125;;a.bar(); //&#39;0&#39;</code></pre><p>打印结果为 <code>0</code>，即这里的 <code>this</code> 指向是对象 <code>a</code>，<code>a.bar()</code>,很明显，这里是对象 <code>a</code> 调用的方法 <code>bar</code>，所以这里的 <code>this</code> 指向对象 <code>a</code>，这种情况也符合 [<strong>谁调用，this 就指向谁</strong>] 。</p></li><li><p>示例三</p><pre><code class="js">var a = &quot;1&quot;;function Test() &#123;  this.a = &quot;0&quot;;&#125;var obj = new Test();obj.a; // &#39;0&#39;`</code></pre><p>打印结果为<code>0</code>，即这里的 this 指向的是通过构造函数生成的新对象，这里情况比较特殊一点，涉及到了构造函数的一些隐式结构，当构造函数生产实例对象时，会在构造函数内容隐式的申明一个 <code>this</code> 的空对象，然后再末尾 return 出去，赋予生产的新对象，所以这里的 <code>this</code> 指向实际上就是新生产的实例对象。</p></li><li><p>示例四</p><pre><code class="js">var a = &quot;0&quot;;var obj = &#123;  a: &quot;1&quot;,  b: &#123;    a: &quot;2&quot;,    bar: function () &#123;      console.log(this.a);    &#125;,  &#125;,&#125;;obj.b.bar(); //&#39;2&#39;</code></pre></li></ul><p>这里打印结果是 <code>2</code>，很明显这里的 <code>this</code> 指向的是 <code>b</code> 对象，通过大量的实验，不难得出一个补充结论， [<strong>谁 <code>直接</code> 调用，<code>this</code> 就指向谁</strong>]，如果我们注释掉 b 对象中的 a 申明，打印结果一定会是 undefined。</p><ul><li><p>示例五 [<code>call()</code>,<code>apply()</code>]</p><pre><code class="js">var a = &#123;  typeName: &quot;call&quot;,  bar: function () &#123;    console.log(this.typeName);  &#125;,&#125;;var f1 = a.bar;f1(); // &#39;undefined&#39;f1.call(a); //&#39;call&#39;var b = &#123;  typeName: &quot;apply &quot;,  bar: function () &#123;    console.log(this.typeName);  &#125;,&#125;;var f2 = b.bar;f2.call(b); //&#39;apply&#39;</code></pre></li></ul><p><code>call()</code>和 <code>apply()</code>能够手动的更改 <code>this</code> 的指向，支持接受多个参数，第一个参数是 <code>this</code> 的具体指向，后面的参数是函数的需要的参数,不同的是 <code>apply()</code>的第二个参数接受一个数组，数组内的值为函数需要的参数。需要注意的是，如果第一个参数为 <code>null</code> 的话，则 <code>this</code> 指向全局。（</p><blockquote><p>tips：js 所有的原型链，最终都指向 Object,但是通过 call(null),apply(null)处理的对象，原型链最终指向是 null）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;this-特点&quot;&gt;&lt;a href=&quot;#this-特点&quot; class=&quot;headerlink&quot; title=&quot;this 特点&quot;&gt;&lt;/a&gt;this 特点&lt;/h5&gt;&lt;p&gt;JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变，所以具有很大的迷惑</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://heybigfish.github.io/categories/JavaScript/"/>
    
    
    <category term="基础" scheme="https://heybigfish.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
