---
title: 单例模式
date: 2021-09-01 16:41:35
tags: [JavaScript, 设计模式]
categories: [JavaScript, 设计模式]
---

**定义：保证一个类仅有一个实例，并提供一个访问它的全局访问节点。**

单例模式是一种常用的模式，有些对象只需要一个，例如全局缓存，window 对象等。
核心思想就是使用一个变量来标志当前是否已经为某个类创建过对象，如果是，则下次获取实例时，直接返回之前创建的对象。

##### 实现单例模式

```js
var Singleton = function (name) {
  this.name = name;
  this.instance = null;
};
Singleton.getInstance = function () {
  if (!this.instance) {
    this.instance = new Singleton(name);
  }
  return this.instance;
};
var a = Singleton.getInstance("sven1");
var b = Singleton.getInstance("sven2");
alert(a === b); // true
```

或者

```js
var Singleton = function (name) {
  this.name = name;
};
Singleton.getInstance = (function () {
  var instance = null;
  return function (name) {
    if (!instance) {
      instance = new Singleton(name);
    }
    return instance;
  };
})();
```

通过 `Singleton.getInstance` 来获取 `Singleton` 类的唯一对象，方法相对简单，但是存在不透明性，不能使用常规的 `new Func` 来创建对象，使用者必须知道这是一个单例类，然后使用定义好的方法创建对象。

##### 透明的单例模式

理想中，可以和其他的普通类一样创建对象。

```js
var Singleton = (function () {
  var instance;
  var CreateObject = function (name) {
    if (instance) {
      return instance;
    }
    this.name = name;
    return (instance = this);
  };
  return CreateObject;
})();
```

虽然完成了一个简单的透明单例，但是也存在一定的缺点：
为了封装 `instance` ,使用了自执行匿名函数和闭包，并且让匿名函数返回了真正的 `Singleton` 构造方法，增加了程序的复杂性，阅读起来也不舒服。

##### 代理实现单例模式

引入代理类的方式，来创建一个单例

- 先创建一个简单的普通构造函数：

```js
var Singleton = function (name) {
  this.name = name;
};
```

- 再创建一个代理类

```js
var ProxySingleton = (function () {
  var instance;
  return function (callback, args) {
    if (!instance) {
      instance = new callback(args);
    }
    return instance;
  };
})();
```

- 实现透明单例

```js
var a = new ProxySingleton(Singleton, "111");
```
